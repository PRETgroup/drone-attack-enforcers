from enum import Enum

#For each policy, we need an enum type for the state machine
# enum attack_enforcer_policy_attack_1_states { 
# 	POLICY_STATE_attack_enforcer_attack_1_s0,
# 	POLICY_STATE_attack_enforcer_attack_1_violation 
# };
class attack_enforcer_policy_attack_1_states(Enum):
    POLICY_STATE_attack_enforcer_attack_1_s0 = 1
    POLICY_STATE_attack_enforcer_attack_1_violation = 2

inputs_attack_enforcer_t = {}
outputs_attack_enforcer_t = {
    "new": False,
    "run": False,
    "end": False,
    "abort": False
}

enforcervars_attack_enforcer_t = {
    "_policy_attack_1_state": attack_enforcer_policy_attack_1_states
}

#This file should be called F_attack_enforcer.c
#This is autogenerated code. Edit by hand at your peril!
#include "F_attack_enforcer.h"

# def attack_enforcer_init_all_vars(enforcervars_attack_enforcer_t, inputs_attack_enforcer_t, outputs_attack_enforcer_t):
def attack_enforcer_init_all_vars(me, inputs, outputs):
	#set any input vars with default values
	
	#set any output vars with default values
	
	me["_policy_attack_1_state"] = attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_s0
	
# def attack_enforcer_run_via_enforcer(enforcervars_attack_enforcer_t, inputs_attack_enforcer_t, outputs_attack_enforcer_t):
def attack_enforcer_run_via_enforcer(me, inputs, outputs):
    #run the policies in reverse order for the inputs (last policies have highest priority)

    attack_enforcer_run_input_enforcer_attack_1(me, inputs)

    attack_enforcer_run(inputs, outputs)

    #run policies in specified order for outputs
    attack_enforcer_run_output_enforcer_attack_1(me, inputs,outputs)
	

#input policies

#INPUT POLICY attack_1 BEGIN
#This will run the input enforcer for attack_enforcer's policy attack_1
# def attack_enforcer_run_input_enforcer_attack_1(enforcervars_attack_enforcer_t* me, inputs_attack_enforcer_t* inputs):
def attack_enforcer_run_input_enforcer_attack_1(me, inputs):
    if me["_policy_attack_1_state"] == attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_s0:
        return
    elif me["_policy_attack_1_state"] == attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_violation:
        return
#INPUT POLICY attack_1 END

#output policies

#OUTPUT POLICY attack_1 BEGIN
#This will run the input enforcer for attack_enforcer's policy attack_1
# def attack_enforcer_run_output_enforcer_attack_1(enforcervars_attack_enforcer_t* me, inputs_attack_enforcer_t* inputs, outputs_attack_enforcer_t* outputs):
def attack_enforcer_run_output_enforcer_attack_1(me, inputs, outputs):
	#advance timers
	
	#run enforcer
    if me["_policy_attack_1_state"] == attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_s0:
        if outputs["abort"]:
           outputs["abort"] = False 
        return
    elif me["_policy_attack_1_state"] == attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_violation:
        return

	#select transition to advance state
    if me["_policy_attack_1_state"] == attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_s0:
        if not outputs["abort"]:
            me["_policy_attack_1_state"] = attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_s0
        if outputs["abort"]:
            me["_policy_attack_1_state"] = attack_enforcer_policy_attack_1_states.POLICY_STATE_attack_enforcer_attack_1_violation

        #ensure a transition was taken in this state
        # assert(false && "attack_enforcer_attack_1_s0 must take a transition"); #if we are still here, then no transition was taken and we are no longer satisfying liveness


	#ensure we did not violate (i.e. we did not enter violation state)
	# assert(me->_policy_attack_1_state != POLICY_STATE_attack_enforcer_attack_1_violation);

#OUTPUT POLICY attack_1 END

def attack_enforcer_run(inputs, outputs):
    return